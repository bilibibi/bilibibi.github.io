<!DOCTYPE html>
<html lang="en">
    <head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
		<title>
				Posts &middot; Hi, I&#39;m Franky.
		</title>
	
		
  		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
	
		
		<link href="https://bilibibi.github.io/post/index.xml" rel="alternate" type="application/rss+xml" title="Hi, I&#39;m Franky." />
	</head>
	
    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">Hi, I&#39;m Franky.</h2>
				</a>
				<ul>
    <li><a href="/about">About</a></li>
    <li><a href="/">Posts</a></li>
</ul>
			</div>
		</nav>

        

<main>
	<div class="catalogue">
		
			<a href="https://bilibibi.github.io/post/study/%E5%A0%86%E5%92%8C%E6%A0%88/" class="catalogue-item">
    <div>
        <time datetime="2019-09-11 12:20:56 &#43;0800 CST" class="catalogue-time">September 11, 2019</time>
        <h1 class="catalogue-title">堆和栈</h1>
        <div class="catalogue-line"></div>

        <p>
            原文：https://www.cnblogs.com/ghj1976/p/3623037.html
1. 预备知识—程序的内存分配 1.1 一个由C/C++编译的程序占用的内存分为以下几个部分  栈区（stack） — 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回 收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 全局区（静态区）（static） —，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放。 文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放。 程序代码区—存放函数体的二进制代码。  1.2 例子程序 这是一个前辈写的，非常详细
//main.cpp int a = 0; // 全局初始化区 char *p1; // 全局未初始化区 main() { int b; // 栈 char s[] = &quot;abc&quot;; // 栈 char *p2; // 栈 char *p3 = &quot;123456&quot;; // 123456/0在常量区，p3在栈上。 static int c =0； // 全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); // 分配得来得10和20字节的区域就在堆区。 strcpy(p1, &quot;123456&quot;); // 123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot; 优化成一个地方。 }  2.
        </p>
    </div>
</a>

		
			<a href="https://bilibibi.github.io/post/study/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/" class="catalogue-item">
    <div>
        <time datetime="2019-08-22 01:55:43 &#43;0800 CST" class="catalogue-time">August 22, 2019</time>
        <h1 class="catalogue-title">进程与线程的联系和区别</h1>
        <div class="catalogue-line"></div>

        <p>
             原文：https://www.jianshu.com/p/a4fa4edbeb8a
1、线程的基本概念 概念：  线程是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。
 好处 ：  （1）易于调度。 （2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。 （3）开销少。创建线程比创建进程要快，所需开销很少。。 （4）利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。
 2、进程的基本状态及状态之间的关系 状态：运行、阻塞、挂起阻塞、就绪、挂起就绪  状态之间的转换：准备就绪的进程，被CPU调度执行，变成运行态； 运行中的进程，进行I/O请求或者不能得到所请求的资源，变成阻塞态； 运行中的进程，进程执行完毕（或时间片已到），变成就绪态； 将阻塞态的进程挂起，变成挂起阻塞态，当导致进程阻塞的I/O操作在用户重启进程前完成（称之为唤醒），挂起阻塞态变成挂起就绪态，当用户在I/O操作结束之前重启进程，挂起阻塞态变成阻塞态； 将就绪（或运行）中的进程挂起，变成挂起就绪态，当该进程恢复之后，挂起就绪态变成就绪态；
 3、线程和进程的关系以及区别？ 进程和线程的关系：  （1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 （2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。 （3）处理机分给线程，即真正在处理机上运行的是线程。 （4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体.
 进程与线程的区别：  （1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 （2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 （3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. （4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
 4、进程间通信的方式  （1）管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
（2）信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
（3）消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
（4）共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
（5）信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
（6）套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。
 5、同步和互斥的区别：  当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。
所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。
所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
 
        </p>
    </div>
</a>

		
			<a href="https://bilibibi.github.io/post/study/%E8%B7%B3%E8%B7%83%E8%A1%A8/" class="catalogue-item">
    <div>
        <time datetime="2019-08-22 00:20:57 &#43;0800 CST" class="catalogue-time">August 22, 2019</time>
        <h1 class="catalogue-title">跳跃表</h1>
        <div class="catalogue-line"></div>

        <p>
            原文：https://www.cnblogs.com/acfox/p/3688607.html
如何让链表的元素查询接近线性时间？
跳跃表的引入 我们知道，普通单链表查询一个元素的时间复杂度为O(n)，即使该单链表是有序的，我们也不能通过二分的方式缩减时间复杂度。
如上图，我们要查询元素为55的结点，必须从头结点，循环遍历到最后一个节点，不算-INF(负无穷)一共查询8次。那么用什么办法能够用更少的次数访问55呢？最直观的，当然是新开辟一条捷径去访问55。
如上图，我们要查询元素为55的结点，只需要在L2层查找4次即可。在这个结构中，查询结点为46的元素将耗费最多的查询次数5次。即先在L2查询46，查询4次后找到元素55，因为链表是有序的，46一定在55的左边，所以L2层没有元素46。然后我们退回到元素37，到它的下一层即L1层继续搜索46。非常幸运，我们只需要再查询1次就能找到46。这样一共耗费5次查询。
那么，如何才能更快的搜寻55呢？有了上面的经验，我们就很容易想到，再开辟一条捷径。
如上图，我们搜索55只需要2次查找即可。这个结构中，查询元素46仍然是最耗时的，需要查询5次。即首先在L3层查找2次，然后在L2层查找2次，最后在L1层查找1次，共5次。很显然，这种思想和2分非常相似，那么我们最后的结构图就应该如下图。
我们可以看到，最耗时的访问46需要6次查询。即L4访问55，L3访问21、55，L2访问37、55，L1访问46。我们直觉上认为，这样的结构会让查询有序链表的某个元素更快。那么究竟算法复杂度是多少呢？
如果有n个元素，因为是2分，所以层数就应该是log n层 (本文所有log都是以2为底)，再加上自身的1层。以上图为例，如果是4个元素，那么分层为L3和L4，再加上本身的L2，一共3层；如果是8个元素，那么就是3+1层。最耗时间的查询自然是访问所有层数，耗时logn+logn，即2logn。为什么是2倍的logn呢？我们以上图中的46为例，查询到46要访问所有的分层，每个分层都要访问2个元素，中间元素和最后一个元素。所以时间复杂度为O(logn)。
至此为止，我们引入了最理想的跳跃表，但是如果想要在上图中插入或者删除一个元素呢？比如我们要插入一个元素22、23、24……，自然在L1层，我们将这些元素插入在元素21后，那么L2层，L3层呢？我们是不是要考虑插入后怎样调整连接，才能维持这个理想的跳跃表结构。我们知道，平衡二叉树的调整是一件令人头痛的事情，左旋右旋左右旋……一般人还真记不住，而调整一个理想的跳跃表将是一个比调整平衡二叉树还复杂的操作。幸运的是，我们并不需要通过复杂的操作调整连接来维护这样完美的跳跃表。有一种基于概率统计的插入算法，也能得到时间复杂度为O(logn)的查询效率，这种跳跃表才是我们真正要实现的。
容易实现的跳跃表 容易实现的跳跃表，它允许简单的插入和删除元素，并提供O(logn)的查询时间复杂度，以下我们简称为跳跃表。
先讨论插入，我们先看理想的跳跃表结构，L2层的元素个数是L1层元素个数的1/2，L3层的元素个数是L2层的元素个数的1/2，以此类推。从这里，我们可以想到，只要在插入时尽量保证上一层的元素个数是下一层元素的1/2，我们的跳跃表就能成为理想的跳跃表。那么怎么样才能在插入时保证上一层元素个数是下一层元素个数的1/2呢？很简单，抛硬币就能解决了！假设元素X要插入跳跃表，很显然，L1层肯定要插入X。那么L2层要不要插入X呢？我们希望上层元素个数是下层元素个数的1/2，所以我们有1/2的概率希望X插入L2层，那么抛一下硬币吧，正面就插入，反面就不插入。那么L3到底要不要插入X呢？相对于L2层，我们还是希望1/2的概率插入，那么继续抛硬币吧！以此类推，元素X插入第n层的概率是(1&frasl;2)的n次。这样，我们能在跳跃表中插入一个元素了。
在此还是以上图为例：跳跃表的初试状态如下图，表中没有一个元素：
如果我们要插入元素2，首先是在底部插入元素2，如下图：
然后我们抛硬币，结果是正面，那么我们要将2插入到L2层，如下图
继续抛硬币，结果是反面，那么元素2的插入操作就停止了，插入后的表结构就是上图所示。接下来，我们插入元素33，跟元素2的插入一样，现在L1层插入33，如下图：
然后抛硬币，结果是反面，那么元素33的插入操作就结束了，插入后的表结构就是上图所示。接下来，我们插入元素55，首先在L1插入55，插入后如下图：
然后抛硬币，结果是正面，那么L2层需要插入55，如下图：
继续抛硬币，结果又是正面，那么L3层需要插入55，如下图：
继续抛硬币，结果又是正面，那么要在L4插入55，结果如下图：
继续抛硬币，结果是反面，那么55的插入结束，表结构就如上图所示。
以此类推，我们插入剩余的元素。当然因为规模小，结果很可能不是一个理想的跳跃表。但是如果元素个数n的规模很大，学过概率论的同学都知道，最终的表结构肯定非常接近于理想跳跃表。
当然，这样的分析在感性上是很直接的，但是时间复杂度的证明实在复杂，在此我就不深究了，感兴趣的可以去看关于跳跃表的paper。
再讨论删除，删除操作没什么讲的，直接删除元素，然后调整一下删除元素后的指针即可。跟普通的链表删除操作完全一样。
再来讨论一下时间复杂度，插入和删除的时间复杂度就是查询元素插入位置的时间复杂度，这不难理解，所以是O(logn)。
Java实现 请查看原文 👆
        </p>
    </div>
</a>

		
			<a href="https://bilibibi.github.io/post/daily/20190319/" class="catalogue-item">
    <div>
        <time datetime="2019-03-19 23:02:50 &#43;0800 CST" class="catalogue-time">March 19, 2019</time>
        <h1 class="catalogue-title">20190319</h1>
        <div class="catalogue-line"></div>

        <p>
            <p>其实我是一个演员。</p>
        </p>
    </div>
</a>

		
			<a href="https://bilibibi.github.io/post/daily/20190318/" class="catalogue-item">
    <div>
        <time datetime="2019-03-18 22:55:25 &#43;0800 CST" class="catalogue-time">March 18, 2019</time>
        <h1 class="catalogue-title">20190318</h1>
        <div class="catalogue-line"></div>

        <p>
            <p>今天上午真的是苦笑不得，送老婆去上班后去公司的路上，不知道今天是怎么了，堵的一塌糊涂，平时堵一下也就半小时的路程，今天硬是开了将近一个小时。好不容易开到公司了，停好车后才发现周末带回家的电脑忘记带了&hellip;</p>
        </p>
    </div>
</a>

		
			<a href="https://bilibibi.github.io/post/daily/20190317/" class="catalogue-item">
    <div>
        <time datetime="2019-03-18 22:55:21 &#43;0800 CST" class="catalogue-time">March 18, 2019</time>
        <h1 class="catalogue-title">20190317</h1>
        <div class="catalogue-line"></div>

        <p>
            恭喜老弟成功订车！🎉🎉🎉
就去了三家4S店，一周内就把车定了下来，这效率杠杠的啊。定了辆银色的雅阁，不知道5月前能不能提到车。现在买车确实挺划算的，建行和招行都能办理免息贷款，老弟贷了6W多3年期，平均每月只要还1800，毫无压力呀。长辈和我们的观念确实不太一样，姨夫想全款买，但是我们就觉得能贷款的话当然是贷款比较好，就算要付利息，那也比全款付掉划算，毕竟这些钱找个稍微利息高的理财投一下或者冒险进下股市也好，而且过两年工资涨了钱也贬值了一些，还这些钱更是小意思了。
本来今天想好好准备下简历的，然而跑了趟萧山回来真的是太累了，都赶上回趟义乌了，抽空再弄吧。
        </p>
    </div>
</a>

		
			<a href="https://bilibibi.github.io/post/daily/20190316/" class="catalogue-item">
    <div>
        <time datetime="2019-03-16 15:05:52 &#43;0800 CST" class="catalogue-time">March 16, 2019</time>
        <h1 class="catalogue-title">20190316</h1>
        <div class="catalogue-line"></div>

        <p>
            <p>刚给家里两个猫主子洗了个澡，洗好后稍微收拾了下，短短一个小时的活已经把老夫的腰给累到了，老了老了。</p>
        </p>
    </div>
</a>

		
			<a href="https://bilibibi.github.io/post/daily/20190315/" class="catalogue-item">
    <div>
        <time datetime="2019-03-15 15:32:08 &#43;0000 UTC" class="catalogue-time">March 15, 2019</time>
        <h1 class="catalogue-title">20190315</h1>
        <div class="catalogue-line"></div>

        <p>
            <p>又到了一年一度的315，不知多少大公司大企业严阵以待，每年的315晚会大概是除春晚外最令人期待的晚会了，甚至有可能还超过了春晚的影响力。</p>
        </p>
    </div>
</a>

		
			<a href="https://bilibibi.github.io/post/daily/20190314/" class="catalogue-item">
    <div>
        <time datetime="2019-03-14 15:00:52 &#43;0000 UTC" class="catalogue-time">March 14, 2019</time>
        <h1 class="catalogue-title">20190314</h1>
        <div class="catalogue-line"></div>

        <p>
            <p>看了一篇面经，一位老哥在实习结束后同时拿到了BAT三家公司offer，甚是羡慕！虽然已经是前两年的文章了，但毕竟是真实经历，所以依然有学习的价值。最后还列了一下常见的问题，我针对他给的问题试着回答一下，就当是为面试做准备了。</p>
        </p>
    </div>
</a>

		
			<a href="https://bilibibi.github.io/post/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%B2%BE%E9%80%89%E5%B7%A5%E4%BD%9C%E5%BF%85%E8%AF%BB%E4%B9%A6/" class="catalogue-item">
    <div>
        <time datetime="2019-03-14 16:03:34 &#43;0800 CST" class="catalogue-time">March 14, 2019</time>
        <h1 class="catalogue-title">互联网产品经理精选工作必读书</h1>
        <div class="catalogue-line"></div>

        <p>
            <p>看了很多推荐产品经理看书的文章，这篇算是比较全的了，记录一下，慢慢看吧~</p>
        </p>
    </div>
</a>

		
	</div>
	
	<div class="pagination">
		
		
			<a href="/post/page/2/" class="right arrow">&#8594;</a>
		
	
		<span>1</span>
	</div>
</main>


        		<footer>
			<span>
			&copy; <time datetime="2019-11-13 10:17:32.51514 &#43;0800 CST m=&#43;0.117069883">2019</time> . Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
